{
  "success": true,
  "data": {
    "errCode": 0,
    "errMsg": "执行成功",
    "data": [
      {
        "_id": "c8872b64687f0b33003b229d3b0c8f49",
        "course_id": 4,
        "id": 42676033,
        "seq": 1,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "软件工程由（  ）  三部分组成。",
        "A": "方法、工具、过程",
        "B": "技术、方法、工具",
        "C": "技术、资源、架构",
        "D": "技术、方法、过程",
        "answer": "A",
        "explanation": "软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。软件工程由方法、工具和过程三个部分组成。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 259,
        "correct_count": 234,
        "correct_prob": "90.3",
        "fav_count": 9,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b229e04cd5a76",
        "course_id": 4,
        "id": 49079862,
        "seq": 2,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "下列关于软件需求相关的叙述，正确的是  （  ）。",
        "A": "软件需求分为三个层次，分别为用户需求、业务需求、功能需求",
        "B": "用户需求通常来自项目投资人、购买产品的客户、市场部门或产品部门等",
        "C": "功能需求通常是通过系统特性的描述表现出来的",
        "D": "功能需求指的是用户要求系统必须能完成的任务和想要达到的结果",
        "answer": "C",
        "explanation": "软件需求就是系统必须完成的事和必须具备的品质。需求是多层次的，包括业务需求、用户需求和系统需求。业务需求通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等。用户需求描述的是用户的具体目标或用户要求系统必须能完成的任务和想要达到的结果。系统需求是从系统的角度来说明软件的需求，包括功能需求、非功能需求和约束等。功能需求也称为行为需求，它规定了开发人员必须在系统中实现的软件功能，用户利用这些功能来完成任务，满足业务需要。功能需求通常是通过系统特性的描述表现出来的。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 256,
        "correct_count": 105,
        "correct_prob": "41.0",
        "fav_count": 20,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b229242b6642b",
        "course_id": 4,
        "id": 44425231,
        "seq": 3,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "是一种将用户要求转化成软件需求的技术，其目的是最大限度地提升软件工程过程中用户的满意度。（  ）",
        "A": "系统需求",
        "B": "业务需求",
        "C": "软件需求",
        "D": "QFD",
        "answer": "D",
        "explanation": "质量功能部署（QFD）是一种将客户要求转化成软件技术需求的技术。QFD的目的是最大限度地让客户从软件工程过程中感到满意。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 63,
        "correct_count": 44,
        "correct_prob": "69.8",
        "fav_count": 10,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22942a7dbaa1",
        "course_id": 4,
        "id": 41656981,
        "seq": 4,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "质量功能部署（QFD）将软件需求分为常规需求、 （  ）和意外需求。",
        "A": "期望需求",
        "B": "业务需求",
        "C": "系统需求",
        "D": "功能需求",
        "answer": "A",
        "explanation": "QFD将软件需求分为三类，分别是常规需求、期望需求和意外需求。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 63,
        "correct_count": 58,
        "correct_prob": "92.1",
        "fav_count": 1,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22be3d85a633",
        "course_id": 4,
        "id": 46415268,
        "seq": 5,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "用户认为系统应具备的功能或性能，如果（  ）没有得到实现，会让用户感到不满意。",
        "A": "期望需求",
        "B": "常规需求",
        "C": "软件需求",
        "D": "用户需求",
        "answer": "A",
        "explanation": "QFD将软件需求分为三类，分别是常规需求、期望需求和意外需求。也要注意区分这些需求：\n1）常规需求。用户认为系统应该做到的功能或性能，实现越多用户会越满意。\n2）期望需求。用户认为系统应具备的功能或性能，但并不能正确描述自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。\n3）意外需求。意外需求也称兴奋需求，是用户要求范围外的功能或性能（但通常是软件开发人员很乐意赋予系统的技术特性，实现这些需求用户会更高兴，但不实现也不影响购买的决策）。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 248,
        "correct_count": 171,
        "correct_prob": "69.0",
        "fav_count": 8,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22bf021ea0d6",
        "course_id": 4,
        "id": 41380509,
        "seq": 6,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "使用结构化（SA）方法进行需求分析，其建立的模型的核心是（  ），围绕这个核心，有三个层次的模型，分别是数据模型、（  ）和行为模型。",
        "A": "数据字典 功能模型",
        "B": "数据流图 系统模型",
        "C": "数据流图 功能模型",
        "D": "数据字典 系统模型",
        "answer": "A",
        "explanation": "结构化分析（Structured Analysis，SA）方法给出一组帮助系统分析人员产生功能规约的原理与技术，其建立模型的核心是数据字典。围绕这个核心，有三个层次的模型，分别是数据模型、功能模型和行为模型（也称为状态模型）。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 60,
        "correct_count": 46,
        "correct_prob": "76.7",
        "fav_count": 7,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22933c4f59aa",
        "course_id": 4,
        "id": 45672447,
        "seq": 7,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "使用结构化（SA）方法进行需求分析，一般使用（  ）表示数据模型，描述实体、属性，以及实体之间的关系。",
        "A": "对象关系图",
        "B": "数据流图",
        "C": "状态转换图",
        "D": "实体关系图",
        "answer": "D",
        "explanation": "在实际工作中，一般使用实体关系图（E-R图）表示数据模型，用数据流图（Data Flow Diagram，DFD）表示功能模型，用状态转换图（State Transform Diagram，STD）表示行为模型。E-R图主要描述实体、属性以及实体之间的关系；DFD从数据传递和加工的角度，利用图形符号通过逐层细分的方法，描述系统内各个部件的功能和数据在它们之间传递的情况，说明系统所完成的功能；STD通过描述系统的状态和引起系统状态转换的事件，表示系统的行为。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 62,
        "correct_count": 50,
        "correct_prob": "80.6",
        "fav_count": 3,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22c178b9635b",
        "course_id": 4,
        "id": 43927672,
        "seq": 8,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在进行结构化分析时，可以通过（  ）了解系统所要完成的功能。",
        "A": "体关系图",
        "B": "数据流图",
        "C": "状态转换图",
        "D": "数据字典",
        "answer": "B",
        "explanation": "在实际工作中，用数据流图（DFD）表示功能模型，DFD从数据传递和加工的角度，利用图形符号通过逐层细分的方法，描述系统内各个部件的功能和数据在它们之间传递的情况，说明系统所完成的功能。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 245,
        "correct_count": 191,
        "correct_prob": "78.0",
        "fav_count": 3,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b2291644f0b5b",
        "course_id": 4,
        "id": 45862986,
        "seq": 9,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "下列（  ）不属于DFD的基本要素。",
        "A": "数据流",
        "B": "数据存储",
        "C": "关系",
        "D": "处理／加工",
        "answer": "C",
        "explanation": "DFD方法由以下四种基本元素（模型对象）组成：数据流、处理／加工、数据存储和外部项。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 65,
        "correct_count": 41,
        "correct_prob": "63.1",
        "fav_count": 10,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22bb60e25e47",
        "course_id": 4,
        "id": 44259181,
        "seq": 10,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "如果使用DFD对某企业的财务系统进行建模，那该系统中（  ）可以被认定为外部项。",
        "A": "转账单",
        "B": "转账单输入",
        "C": "财务系统源代码程序",
        "D": "接收转账单的银行",
        "answer": "D",
        "explanation": "DFD方法由以下四种基本元素（模型对象）组成：数据流、处理／加工、数据存储和外部项。外部项也称为数据源或者数据终点，是描述系统数据的提供者或者数据的使用者，如教师、学生、采购员、某个组织或部门或其他系统。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 152,
        "correct_count": 116,
        "correct_prob": "76.3",
        "fav_count": 3,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22a033a3edde",
        "course_id": 4,
        "id": 46952740,
        "seq": 11,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "数据字典是结构化分析的重要工具。下列（  ）不属于数据字典的组成部分。",
        "A": "数据项",
        "B": "数据流",
        "C": "处理过程",
        "D": "外部实体",
        "answer": "D",
        "explanation": "数据字典主要包括数据项、数据结构、数据流、数据存储、处理过程等几个部分。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 61,
        "correct_count": 41,
        "correct_prob": "67.2",
        "fav_count": 11,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22b02a62ca0b",
        "course_id": 4,
        "id": 45565232,
        "seq": 12,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "数据字典是结构化分析的重要工具。数据字典是（ ） 。",
        "A": "描述数据的信息集合",
        "B": "数据库中的数据",
        "C": "查询数据的字典",
        "D": "不可更新的",
        "answer": "A",
        "explanation": "数据字典是描述数据的信息集合，是对系统中使用的所有数据元素定义的集合。数据字典的作用是给数据流图上的每个元素加以定义和说明。换句话说，数据流图上所有元素的定义和解释的文字集合就是数据字典。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 249,
        "correct_count": 161,
        "correct_prob": "64.7",
        "fav_count": 5,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22c548684ea8",
        "course_id": 4,
        "id": 41945468,
        "seq": 13,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "下列（  ）不属于面向对象分析（OOA）的基本原则。",
        "A": "抽象",
        "B": "多态",
        "C": "消息通信",
        "D": "粒度控制",
        "answer": "B",
        "explanation": "面向对象分析（Object-Oriented Analysis，OOA）的基本原则主要包括抽象、封装、继承、分类、聚合、关联、消息通信、粒度控制和行为分析。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 63,
        "correct_count": 22,
        "correct_prob": "34.9",
        "fav_count": 17,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22b173abac0a",
        "course_id": 4,
        "id": 44639346,
        "seq": 14,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "(  )是OOA的核心原则，它强调把数据和操作结合为一个不可分的系统单位，对象的外部只需要知道它做什么，而不必知道它如何做。",
        "A": "抽象",
        "B": "封装",
        "C": "聚合",
        "D": "分类",
        "answer": "A",
        "explanation": "数据抽象是OOA的核心原则，它强调把数据（属性）和操作（服务）结合为一个不可分的系统单位（对象），对象的外部只需要知道它做什么，而不必知道它如何做。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 62,
        "correct_count": 27,
        "correct_prob": "43.5",
        "fav_count": 14,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22c6577c7c7b",
        "course_id": 4,
        "id": 41947893,
        "seq": 15,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在当前的软件开发过程中，需求变更已经成为一种常态。下列关于需求变更的说法，不正确的是（  ）。",
        "A": "所有需求变更必须遵循变更控制过程",
        "B": "应该由项目经理决定实现哪些变更",
        "C": "对于未获得批准的变更，不应该做设计和实现工作",
        "D": "每一个集成的需求变更必须能跟踪到一个经核准的变更请求",
        "answer": "B",
        "explanation": "应该由项目变更控制委员会决定实现哪些变更，而不是项目经理决定。常见的需求变更策略如下。\n·所有需求变更必须遵循变更控制过程。\n·对于未获得批准的变更，不应该做设计和实现工作。\n·应该由项目变更控制委员会决定实现哪些变更。\n·项目风险承担者应该能够了解变更的内容。\n·绝不能从项目配置库中删除或者修改变更请求的原始文档。\n·每一个集成的需求变更必须能跟踪到一个经核准的变更请求",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 244,
        "correct_count": 208,
        "correct_prob": "85.2",
        "fav_count": 0,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22a46116ae79",
        "course_id": 4,
        "id": 43291330,
        "seq": 16,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在需求跟踪过程中，检查代码、测试用例等工作成果都能在软件需求规格说明书中找到出处的方法属于（  ）。",
        "A": "逆向跟踪",
        "B": "正向跟踪",
        "C": "双向跟踪",
        "D": "系统跟踪",
        "answer": "A",
        "explanation": "需求跟踪有正向跟踪和逆向跟踪两种方式。\n·正向跟踪：检查SRS中的每个需求是否都能在后继工作成果中找到对应点。\n·逆向跟踪：检查设计文档、代码、测试用例等工作成果是否都能在SRS中找到出处。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 255,
        "correct_count": 162,
        "correct_prob": "63.5",
        "fav_count": 6,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22ae64564e8f",
        "course_id": 4,
        "id": 49695724,
        "seq": 17,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "软件开发完成，项目经理小赵正在根据《软件需求规格说明书》检查每个需求是否均正确实现。这种方法在需求跟踪中属于（  ） 。",
        "A": "逆向跟踪",
        "B": "正向跟踪",
        "C": "双向跟踪",
        "D": "系统跟踪",
        "answer": "B",
        "explanation": "正向跟踪：检查SRS中的每个需求是否都能在后继工作成果中找到对应点。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 69,
        "correct_count": 62,
        "correct_prob": "89.9",
        "fav_count": 1,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22b20e6e23d1",
        "course_id": 4,
        "id": 44677261,
        "seq": 18,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "结构化设计（SD）是一种面向数据流的系统设计方法，它以（ 本题 ）  等文档为基础，是一个（  ）、逐步求精和模块化的过程。",
        "A": "数据流图和数据字典",
        "B": "软件需求规格说明书",
        "C": "数据流转说明书",
        "D": "业务流程说明书",
        "answer": "A",
        "explanation": "结构化设计（Structured Design，SD）是一种面向数据流的方法，其目的在于确定软件结构。它以SRS和SA阶段所产生的数据流图和数据字典等文档为基础。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 147,
        "correct_count": 106,
        "correct_prob": "72.1",
        "fav_count": 8,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b228d148e046d",
        "course_id": 4,
        "id": 46034692,
        "seq": 19,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "结构化设计（SD）是一种面向数据流的系统设计方法，它以（  ）  等文档为基础，是一个（本题）、逐步求精和模块化的过程。",
        "A": "自底向上",
        "B": "自顶向下",
        "C": "原型化",
        "D": "层次化",
        "answer": "B",
        "explanation": "结构化设计（SD）是一个自顶向下、逐层分解、逐步求精和模块化的过程。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 65,
        "correct_count": 52,
        "correct_prob": "80.0",
        "fav_count": 3,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22c77f653b40",
        "course_id": 4,
        "id": 44404686,
        "seq": 20,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "SD方法的基本思想是将软件设计成由相对独立且具有单一功能的模块，其中（ ）阶段的主要任务是确定软件系统的结构，对软件系统进行模块划分，确定每个模块的功能、接口和模块之间的调用关系。",
        "A": "模块设计",
        "B": "详细设计",
        "C": "概要设计",
        "D": "架构设计",
        "answer": "C",
        "explanation": "SD方法的基本思想是将软件设计成由相对独立且具有单一功能的模块组成的结构。从管理角度讲，其分为概要设计和详细设计两个阶段。其中，概要设计又称为总体结构设计，它是开发过程中很关键的一步，其主要任务是确定软件系统的结构，将系统的功能需求进行模块划分，确定每个模块的功能、接口和模块之间的调用关系，形成软件的模块结构图，即系统结构图。在概要设计中，将系统开发的总任务分解成许多个基本的、具体的任务，而为每个具体任务选择适当的技术手段和处理方法的过程称为详细设计。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 249,
        "correct_count": 172,
        "correct_prob": "69.1",
        "fav_count": 17,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b2296749dd2cb",
        "course_id": 4,
        "id": 42149559,
        "seq": 21,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "模块A通过非正常入口转入模块B内部，则这两个模块之间是（  ）耦合。",
        "A": "数据",
        "B": "通信",
        "C": "外部",
        "D": "内容",
        "answer": "D",
        "explanation": "数据耦合是通过参数表传递简单信息。公共耦合是多个模块访问同一个公共数据环境。外部耦合是一组模块访问同一个全局简单变量而没有通过参数表传递。内容耦合是一个模块直接访问另一个模块的内部数据；一个模块不通过正常入口转到另一个模块的内部；两个模块有一部分程序代码重叠；一个模块有多个入口。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 58,
        "correct_count": 19,
        "correct_prob": "32.8",
        "fav_count": 18,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22972891ca45",
        "course_id": 4,
        "id": 42222033,
        "seq": 22,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "软件设计过程中，尽量遵循的设计原则是（  ）。",
        "A": "高内聚、低耦合",
        "B": "高内聚、高耦合",
        "C": "低内聚、高耦合",
        "D": "低内聚、低耦合",
        "answer": "A",
        "explanation": "耦合低使得模块间尽可能相对独立，各模块可以单独开发和维护；内聚高使得模块的可理解性和维护性大大增强。因此，在模块的分解中应尽量减少模块的耦合，力求增加模块的内聚，遵循“高内聚、低耦合”的设计原则。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 149,
        "correct_count": 115,
        "correct_prob": "77.2",
        "fav_count": 0,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b228f7eef6852",
        "course_id": 4,
        "id": 48070469,
        "seq": 23,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "内聚衡量一个模块内部各个元素彼此结合的紧密程度，以下属于高内聚的是  （ ） 。",
        "A": "偶然内聚",
        "B": "时间内聚",
        "C": "功能内聚",
        "D": "逻辑内聚",
        "answer": "C",
        "explanation": "软件模块内聚从高到低排列如下。\n1）功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。\n2）顺序内聚：处理元素相关，而且必须顺序执行。\n3）通信内聚：所有处理元素集中在一个数据结构的区域上。\n4）过程内聚：处理元素相关，而且必须按特定的次序执行。\n5）瞬时内聚（时间内聚）：所包含的任务必须在同一时间间隔内执行。\n6）逻辑内聚：完成逻辑上相关的一组任务。\n7）偶然内聚（巧合内聚）：完成一组没有关系或松散关系的任务。\n其中内聚最高的为功能内聚。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 61,
        "correct_count": 43,
        "correct_prob": "70.5",
        "fav_count": 9,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b229a1709f710",
        "course_id": 4,
        "id": 44684950,
        "seq": 24,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "关于面向对象设计（OOD）的说法，错误的是（   ）。",
        "A": "面向对象设计的基本思想包括抽象、封装和继承",
        "B": "对象继承和多态可用来实现可扩展性",
        "C": "OOD的结果就是设计模型",
        "D": "提高软件的可维护性和可复用性，是OOD需要解决的核心问题",
        "answer": "A",
        "explanation": "面向对象设计的基本思想包括抽象、封装和可扩展性，其中可扩展性是通过对象继承和多态来实现的。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 253,
        "correct_count": 180,
        "correct_prob": "71.1",
        "fav_count": 18,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22a55abc08a2",
        "course_id": 4,
        "id": 44312136,
        "seq": 25,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在OOD中，可维护性的复用是以设计原则为基础的。其中应用OOD（  ）的原则，可扩展已有的系统，并为之提供新的行为。",
        "A": "开闭",
        "B": "里氏替换",
        "C": "依赖倒置",
        "D": "接口隔离",
        "answer": "A",
        "explanation": "面向对象设计原则可以有效地提高系统的复用性和可维护性。开闭原则规定对象对扩展开放，对修改封闭。当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 60,
        "correct_count": 30,
        "correct_prob": "50.0",
        "fav_count": 13,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22c25f6806c5",
        "course_id": 4,
        "id": 40538162,
        "seq": 26,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在使用面向对象设计方法时，（  ）原则建议在面向对象程序设计中，应尽量针对接口编程，而不是针对实现编程。",
        "A": "里氏替换",
        "B": "依赖倒置",
        "C": "最小知识",
        "D": "接口隔离",
        "answer": "B",
        "explanation": "依赖倒置原则规定程序要依赖于抽象，不要依赖于具体实现；要针对接口编程，不要针对实现编程。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 147,
        "correct_count": 112,
        "correct_prob": "76.2",
        "fav_count": 16,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22c86a0a17bf",
        "course_id": 4,
        "id": 46558506,
        "seq": 27,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "统一建模语言（UML）属于（  ） 。",
        "A": "软件需求工具",
        "B": "软件开发语言",
        "C": "软件编译工具",
        "D": "软件测试工具",
        "answer": "A",
        "explanation": "统一建模语言（Unified Modeing Language，UML）用于对软件进行可视化描述、构造和建立软件系统的文档。UML适用于各种软件开发方法、软件生命周期的各个阶段、各种应用领域以及各种开发工具，是一种总结了以往建模技术的经验并吸收当今优秀成果的标准建模方法。需要注意的是，UML是一种可视化的建模语言，而不是编程语言。软件需求工具包括需求建模工具和需求追踪工具，UML属于软件需求工具",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 253,
        "correct_count": 221,
        "correct_prob": "87.4",
        "fav_count": 10,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22b5440e0d2e",
        "course_id": 4,
        "id": 40149916,
        "seq": 28,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "统一建模语言（UML）的结构由（  ） 三部分组成。",
        "A": "事物、关系、图",
        "B": "构造块、规则、公共机制",
        "C": "方法、过程、工具",
        "D": "技术、管理、知识",
        "answer": "B",
        "explanation": "统一建模语言（UML）是一种定义良好、易于表达、功能强大且普遍适用的建模语言。UML的结构包括构造块、规则和公共机制三个部分。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 63,
        "correct_count": 36,
        "correct_prob": "57.1",
        "fav_count": 16,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22c30d321e88",
        "course_id": 4,
        "id": 47001424,
        "seq": 29,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "UML有三种基本的构造块，类、接口、构件属于 (   )  构造块。",
        "A": "事物",
        "B": "关系",
        "C": "规则",
        "D": "图",
        "answer": "A",
        "explanation": "UML有七种结构事物，分别是类、接口、协作、用例、活动类、构件和节点。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 146,
        "correct_count": 85,
        "correct_prob": "58.2",
        "fav_count": 4,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22b666626a20",
        "course_id": 4,
        "id": 43579325,
        "seq": 30,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "UML用关系把事物结合在一起，主要有四种关系。若将多边形与三角形、四边形分别设计为类，多边形类与三角形之间是（  ）关系。",
        "A": "依赖",
        "B": "关联",
        "C": "泛化",
        "D": "多态",
        "answer": "C",
        "explanation": "泛化是一般元素和特殊元素之间的分类关系，描述特殊元素的对象可替换一般元素的对象。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 243,
        "correct_count": 175,
        "correct_prob": "72.0",
        "fav_count": 7,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22c90d8a8572",
        "course_id": 4,
        "id": 40258786,
        "seq": 31,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "（ ）将不同的模型元素（例如，类）连接起来，其中的一个类指定了由另一个类保证执行的契约。",
        "A": "依赖",
        "B": "关联",
        "C": "组合",
        "D": "实现",
        "answer": "D",
        "explanation": "实现将不同的模型元素（例如，类）连接起来，其中的一个类指定了由另一个类保证执行的契约。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 62,
        "correct_count": 23,
        "correct_prob": "37.1",
        "fav_count": 13,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22ca58406d49",
        "course_id": 4,
        "id": 40230434,
        "seq": 32,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在统一建模语言（UML）中，（  ）展现了一组对象以及它们之间的关系，给出了系统的静态设计视图或静态进程视图。",
        "A": "序列图",
        "B": "状态图",
        "C": "对象图",
        "D": "通信图",
        "answer": "C",
        "explanation": "在UML中，对象图展现了一组对象以及它们之间的关系，描述了在类图中所建立的事物实例的静态快照，从真实的或原型案例的角度给出系统的静态设计视图或静态进程视图。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 150,
        "correct_count": 108,
        "correct_prob": "72.0",
        "fav_count": 10,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22a94cdfd19d",
        "course_id": 4,
        "id": 40422422,
        "seq": 33,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在统一建模语言（UML）中，  （ ）描述由模型本身分解而成的组织单元，以及它们之间的依赖关系。",
        "A": "构件图",
        "B": "用例图",
        "C": "对象图",
        "D": "包图",
        "answer": "D",
        "explanation": "在UML中，包图描述由模型本身分解而成的组织单元，以及它们之间的依赖关系。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 245,
        "correct_count": 183,
        "correct_prob": "74.7",
        "fav_count": 13,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22901441ff8d",
        "course_id": 4,
        "id": 46082616,
        "seq": 34,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在UML提供的系统视图中，（ 本题 ）是逻辑视图的一次执行实例，描述了并发与同步结构；（  ）是最基本的需求分析模型。",
        "A": "进程视图",
        "B": "实现视图",
        "C": "部署视图",
        "D": "用例视图",
        "answer": "A",
        "explanation": "UML对系统架构的定义是系统的组织结构，包括系统分解的组成部分，以及它们的关联性、交互机制和指导原则等提供系统设计的信息。具体来说，就是指以下五个系统视图：1）逻辑视图。逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。\n2）进程视图。进程视图是可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。\n3）实现视图。实现视图对组成基于系统的物理代码的文件和构件进行建模。\n4）部署视图。部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。\n5）用例视图。用例视图是最基本的需求分析模型。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 60,
        "correct_count": 32,
        "correct_prob": "53.3",
        "fav_count": 10,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22ab64763c3c",
        "course_id": 4,
        "id": 41147275,
        "seq": 35,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在UML提供的系统视图中，（ ）是逻辑视图的一次执行实例，描述了并发与同步结构；（本题）是最基本的需求分析模型。",
        "A": "进程视图",
        "B": "实现视图",
        "C": "部署视图",
        "D": "用例视图",
        "answer": "D",
        "explanation": "UML对系统架构的定义是系统的组织结构，包括系统分解的组成部分，以及它们的关联性、交互机制和指导原则等提供系统设计的信息。具体来说，就是指以下五个系统视图：1）逻辑视图。逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。\n2）进程视图。进程视图是可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。\n3）实现视图。实现视图对组成基于系统的物理代码的文件和构件进行建模。\n4）部署视图。部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。\n5）用例视图。用例视图是最基本的需求分析模型。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 151,
        "correct_count": 118,
        "correct_prob": "78.1",
        "fav_count": 6,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22cb262249cf",
        "course_id": 4,
        "id": 40990290,
        "seq": 36,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "关于软件配置管理（SCM）的说法，错误的是（ ）。",
        "A": "软件配置管理的目的是使错误降为最小，并最有效地提高生产效率",
        "B": "软件配置的核心是版本控制和变更控制",
        "C": "版本控制的功能主要是追踪文件的变更和并行开发",
        "D": "变更控制的目的是控制变更的发生",
        "answer": "D",
        "explanation": "变更控制的目的并不是控制变更的发生，而是对变更进行管理，确保变更有序进行。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 251,
        "correct_count": 221,
        "correct_prob": "88.0",
        "fav_count": 2,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22ac4d5b08f5",
        "course_id": 4,
        "id": 41247359,
        "seq": 37,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "关于软件测试，说法正确的是（  ）。",
        "A": "测试是在编码测试阶段完成后才开始的活动",
        "B": "软件测试工作的好坏，取决于测试发现错误的数量",
        "C": "软件测试的目的是缩短软件开发的时间",
        "D": "软件测试方法可分为静态测试和动态测试",
        "answer": "D",
        "explanation": "软件测试不再是一种仅在编码阶段完成后才开始的活动，而是应该包括在整个开发和维护过程中的活动，它本身也是实际产品构造的一个组成部分。通过测试，发现软件缺陷，为软件产品的质量测量和评价提供依据。软件测试的目的就是确保软件的质量，确认软件以正确的方法检查软件是否做了用户期望的事情。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 251,
        "correct_count": 190,
        "correct_prob": "75.7",
        "fav_count": 0,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22a62a340a9f",
        "course_id": 4,
        "id": 48463339,
        "seq": 38,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "(  )不是静态测试的方法。",
        "A": "白盒测试",
        "B": "桌前检查",
        "C": "检查单",
        "D": "代码审查",
        "answer": "A",
        "explanation": "静态测试包括对文档的静态测试和对代码的静态测试。对文档的静态测试主要以检查单的形式进行，而对代码的静态测试一般采用桌前检查（Desk Checking）、代码走查和代码审查的方式。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 63,
        "correct_count": 54,
        "correct_prob": "85.7",
        "fav_count": 5,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22985ecbe881",
        "course_id": 4,
        "id": 43050462,
        "seq": 39,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "(  )按照程序内部的结构测试程序，检验程序中的每条通路是否都能按预定要求正确工作，而不考虑它的功能。",
        "A": "黑盒测试",
        "B": "白盒测试",
        "C": "代码审查",
        "D": "动态测试",
        "answer": "B",
        "explanation": "白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。这一方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 153,
        "correct_count": 88,
        "correct_prob": "57.5",
        "fav_count": 9,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22bc03c8bd4f",
        "course_id": 4,
        "id": 48684706,
        "seq": 40,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "单元测试主要是对软件的模块进行测试，单元测试的测试用例主要根据（ ）的内容来设计。",
        "A": "需求分析",
        "B": "软件编程",
        "C": "概要设计",
        "D": "详细设计",
        "answer": "D",
        "explanation": "单元测试的技术依据是软件详细设计说明书，其目的是检查每个模块能否正确地实现设计说明书中的功能、性能、接口和其他设计约束等条件。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 252,
        "correct_count": 155,
        "correct_prob": "61.5",
        "fav_count": 16,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b229932def525",
        "course_id": 4,
        "id": 47625327,
        "seq": 41,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "测试所发现的缺陷全部归零是（ ）的结束标志。",
        "A": "系统测试",
        "B": "回归测试",
        "C": "确认测试",
        "D": "第三方测试",
        "answer": "A",
        "explanation": "系统测试的对象是完整的、集成的计算机系统，系统测试的结束标志是测试工作已满足测试目标所规定的需求覆盖率，并且测试所发现的缺陷已全部归零。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 151,
        "correct_count": 98,
        "correct_prob": "64.9",
        "fav_count": 12,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22a76e89023b",
        "course_id": 4,
        "id": 44308723,
        "seq": 42,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "（ ）用于验证软件的功能、性能和其他特性是否与用户需求一致。",
        "A": "系统测试",
        "B": "回归测试",
        "C": "确认测试",
        "D": "第三方测试",
        "answer": "C",
        "explanation": "确认测试主要用于验证软件的功能、性能和其他特性是否与用户需求一致。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 255,
        "correct_count": 222,
        "correct_prob": "87.1",
        "fav_count": 5,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22b379839259",
        "course_id": 4,
        "id": 40085609,
        "seq": 43,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "某软件新版本上线时，项目团队使用（ ）的方式先让少量的用户使用新版本，如果一切正常，就稳步地将新版本适配给所有的用户。",
        "A": "蓝绿部署",
        "B": "金丝雀部署",
        "C": "滚动部署",
        "D": "分布式部署",
        "answer": "B",
        "explanation": "金丝雀部署是指当有新版本发布的时候，先让少量的用户使用新版本，并且观察新版本是否存在问题，如果出现问题，就及时处理并重新发布，如果一切正常，就稳步地将新版本适配给所有的用户。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 254,
        "correct_count": 235,
        "correct_prob": "92.5",
        "fav_count": 0,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22aa0cacf6f2",
        "course_id": 4,
        "id": 44086568,
        "seq": 44,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "（ ）指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速地将用户环境切回旧版本，并对新版本进行修复和调整。",
        "A": "蓝绿部署",
        "B": "金丝雀部署",
        "C": "滚动部署",
        "D": "分布式部署",
        "answer": "A",
        "explanation": "蓝绿部署指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速地将用户环境切回旧版本，并对新版本进行修复和调整。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 58,
        "correct_count": 55,
        "correct_prob": "94.8",
        "fav_count": 2,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22a152c44997",
        "course_id": 4,
        "id": 42731789,
        "seq": 45,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "影响软件质量的三个主要因素是产品运行、产品修改、（  ） 。",
        "A": "产品设计",
        "B": "产品转移",
        "C": "产品复用",
        "D": "产品风险",
        "answer": "B",
        "explanation": "影响软件质量的三个主要因素是产品运行、产品修改和产品转移",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 65,
        "correct_count": 42,
        "correct_prob": "64.6",
        "fav_count": 11,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b228e427aa5fe",
        "course_id": 4,
        "id": 45418329,
        "seq": 46,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "关于软件质量保证的说法，不正确的是（ ）。",
        "A": "着重于检查",
        "B": "贯穿所有活动",
        "C": "作用于过程而不是最终产品",
        "D": "不让缺陷扩散到下一个阶段",
        "answer": "A",
        "explanation": "软件质量保证的关注点集中在一开始就避免缺陷的产生。质量保证的主要目标是：\n·事前预防工作，例如，着重于缺陷预防而不是缺陷检查。\n·尽量在刚刚引入缺陷时即将其捕获，而不是让缺陷扩散到下一个阶段。\n·作用于过程而不是最终产品，因此它有可能会带来广泛的影响与巨大的收益。\n·贯穿于所有的活动之中，而不是只集中于一点。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 256,
        "correct_count": 157,
        "correct_prob": "61.3",
        "fav_count": 11,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22b456331f12",
        "course_id": 4,
        "id": 47539348,
        "seq": 47,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "软件过程能力成熟度模型由四个能力域组成，其中不包括（ ）。",
        "A": "治理",
        "B": "组织资源",
        "C": "管理与支持",
        "D": "组织管理",
        "answer": "B",
        "explanation": "软件过程能力成熟度模型由四个能力域组成，包括治理、开发与交付、管理与支持、组织管理。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 61,
        "correct_count": 41,
        "correct_prob": "67.2",
        "fav_count": 11,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b229f7cc7a2f4",
        "course_id": 4,
        "id": 45300687,
        "seq": 48,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "在CSMM定义的软件过程能力成熟度模型中，下列不属于管理与支持能力域的是（ ） 。",
        "A": "项目监控",
        "B": "战略支持",
        "C": "质量保证",
        "D": "项目策划",
        "answer": "B",
        "explanation": "管理与支持能力域包括项目策划、项目监控、项目结项、质量保证、风险管理、配置管理、供应商管理能力子域，这些能力子域覆盖了软件开发项目的全过程，以确保软件项目能够按照既定的成本、进度和质量交付，能够满足顾客与利益相关方的要求。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 148,
        "correct_count": 106,
        "correct_prob": "71.6",
        "fav_count": 10,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22b747ddd921",
        "course_id": 4,
        "id": 47529975,
        "seq": 49,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "软件过程能力成熟度模型（CSMM）分为五个等级，其中（ ）指的是在组织范围内能够稳定地实现预期的项目目标。",
        "A": "项目规范级",
        "B": "可重复级",
        "C": "已定义级",
        "D": "组织改进级",
        "answer": "D",
        "explanation": "组织改进级指在组织范围内能够稳定地实现预期的项目目标。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 145,
        "correct_count": 82,
        "correct_prob": "56.6",
        "fav_count": 16,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22a248069522",
        "course_id": 4,
        "id": 42613119,
        "seq": 50,
        "test_id": "area_05_03",
        "type": 1,
        "area": 5,
        "tigan": "“采用有效的数据分析技术，分析关键软件过程的能力，预测结果，识别和解决目标实现的问题以达成目标”说明软件过程能力的成熟度处于（ ） 。",
        "A": "引流创新级",
        "B": "稳健管理级",
        "C": "量化提升级",
        "D": "组织改进级",
        "answer": "C",
        "explanation": "量化提升级指在组织范围内能够量化地管理和实现预期的组织和项目目标。采用有效的数据分析技术，分析关键软件过程的能力，预测结果，识别和解决目标实现的问题以达成目标，应用先进实践，提升软件过程效率或质量。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 253,
        "correct_count": 216,
        "correct_prob": "85.4",
        "fav_count": 7,
        "sim_questions": ""
      }
    ]
  },
  "header": {
    "x-serverless-request-id": "ac1cc3151757058938717163571",
    "x-serverless-runtime-version": "2.1.3",
    "date": "Fri, 05 Sep 2025 07:55:38 GMT",
    "x-fc-invocation-function-version": "LATEST",
    "x-fc-instance-id": "c-68ba942f-18af72b7-a9dcac77fee5",
    "x-fc-invocation-duration": "80",
    "x-fc-request-id": "1-68ba977a-181ba6a7-c4d393e32f86",
    "transfer-encoding": "chunked",
    "content-type": "application/octet-stream",
    "x-fc-max-memory-usage": "34.18",
    "access-control-expose-headers": "Date,x-fc-request-id,x-fc-error-type,x-fc-code-checksum,x-fc-invocation-duration,x-fc-max-memory-usage,x-fc-log-result,x-fc-invocation-code-version,x-fc-instance-id",
    "x-fc-code-checksum": "3373688905125190371",
    "x-serverless-http-status": "200"
  }
}