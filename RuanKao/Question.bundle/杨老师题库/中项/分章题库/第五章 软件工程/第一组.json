{
  "success": true,
  "data": {
    "errCode": 0,
    "errMsg": "执行成功",
    "data": [
      {
        "_id": "c8872b64687f0b33003b22184ffc1f3f",
        "course_id": 4,
        "id": 41588083,
        "seq": 1,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "关于软件工程的描述，不正确的是（）。",
        "A": "软件工程对软件开发的质量、进度、成本进行评估、管理和控制",
        "B": "用户需求反映客户高层次的目标要求，通常由项目投资人、客户提出",
        "C": "需求是用户对新系统在功能、行为、性能等方面的期望",
        "D": "软件工程将系统的、规范的、可度量的工程化方法应用于软件开发",
        "answer": "B",
        "explanation": "P202-P203，B答案是业务需求的内容，不是用户需求。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 112,
        "correct_count": 89,
        "correct_prob": "79.5",
        "fav_count": 7,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b21fe77c1a296",
        "course_id": 4,
        "id": 40764132,
        "seq": 2,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）不是软件需求的常用层次。",
        "A": "业务需求",
        "B": "数据需求",
        "C": "用户需求",
        "D": "系统需求",
        "answer": "B",
        "explanation": "P203，需求是多层次的，包括业务需求、用户需求和系统需求，这3个不同层次的需求从目标到具体，从整体到局部，从概念到细节。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 528,
        "correct_count": 481,
        "correct_prob": "91.1",
        "fav_count": 9,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b225260973f76",
        "course_id": 4,
        "id": 49195910,
        "seq": 3,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "以下软件需求变更策略中，不正确的是：（）。",
        "A": "所有需求变更必须遵循变更控制过程",
        "B": "对于未获得批准的变更，不应该做设计和实现工作",
        "C": "应该由项目经理决定实现哪些变更",
        "D": "项目风险承担者应该能够了解变更的内容",
        "answer": "C",
        "explanation": "P210-211，A选项：变更控制过程用来跟踪已建议变更的状态，以确保已建议的变更不会丢失或疏忽。一旦确定了需求基线，应该使所有已建议的变更都遵循变更控制过程。\nB、D选项：变更策略中提到对于未获得批准的变更，不应该做设计和实现工作。项目风险承担者应该能够了解变更的内容。\nC选项：应该由项目变更控制委员会决定实现哪些变更。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 111,
        "correct_count": 101,
        "correct_prob": "91.0",
        "fav_count": 0,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b222e7eb8d518",
        "course_id": 4,
        "id": 40754878,
        "seq": 4,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "QFD将软件需求分为三类，分别是常规需求、（）需求和意外需求。",
        "A": "行为",
        "B": "系统",
        "C": "满足",
        "D": "期望",
        "answer": "D",
        "explanation": "P203，质量功能部署是一种将用户要求转化成软件需求的技术，其目的是最大限度地提升软件工程过程中用户的满意度。为了达到这个目标，QFD将软件需求分为三类，分别是常规需求、期望需求和意外需求，所以选择D。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 111,
        "correct_count": 96,
        "correct_prob": "86.5",
        "fav_count": 10,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22872fce8c3a",
        "course_id": 4,
        "id": 49224690,
        "seq": 5,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "软件需求是多层次的，包括业务需求、用户需求、系统需求，其中业务需求（）。",
        "A": "反映组织机构或用户对系统、产品高层次的目标要求",
        "B": "描述的是用户的具体目标，或用户要求系统必须能完成的任务",
        "C": "从系统的角度来说明软件的需求，包括功能需求、非功能需求和约束",
        "D": "描述了用户认为系统应该具备的功能和性能",
        "answer": "A",
        "explanation": "P203，软件需求就是系统必须完成的事和必须具备的品质。需求是多层次的，包括业务需求、用户需求和系统需求，这3个不同层次从目标到具体，从整体到局部，概念到细节。\n1、业务需求：指反映组织机构或用户对系统、产品高层次的目标要求，从总体上描述了为什么要达到某种效应，组织希望达到什么目标。通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等。\n2、用户需求：描述的是用户的具体目标，或用户要求系统必须能完成的任务和想要达到的结果，这构成了用户原始需求文档的内容。\n3、系统需求：是从系统的角度来说明软件的需求，包括功能需求、非功能需求和约束等。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 101,
        "correct_count": 74,
        "correct_prob": "73.3",
        "fav_count": 15,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b227e4c5485a7",
        "course_id": 4,
        "id": 42079042,
        "seq": 6,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "使用（）进行需求分析，其建立的模型的核心是数据字典。",
        "A": "需求分析方法",
        "B": "结构化分析方法",
        "C": "原型化分析方法",
        "D": "面向对象方法",
        "answer": "B",
        "explanation": "P204，结构化分析（Structured Analysis，SA）方法给出一组帮助系统分析人员产生功能规约的原理与技术，其建立模型的核心是数据字典，所以选择B。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 113,
        "correct_count": 90,
        "correct_prob": "79.6",
        "fav_count": 15,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22275085e662",
        "course_id": 4,
        "id": 46345678,
        "seq": 7,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "在软件需求分析中，（）分别用来表示功能模型和行为模型。",
        "A": "数据流图、状态转换图",
        "B": "状态转换图、E-R图",
        "C": "状态转换图、数据流图",
        "D": "E-R图、状态转换图",
        "answer": "A",
        "explanation": "P204，需求分析在实际工作中，一般使用实体联系图（E-R图）表示数据模型，用数据流图表示功能模型，用状态转换图表示行为模型。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 108,
        "correct_count": 74,
        "correct_prob": "68.5",
        "fav_count": 32,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22284489e72e",
        "course_id": 4,
        "id": 40947173,
        "seq": 8,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "在实际工作中，一般使用状态转换图（State Transform Diagram，STD）表示（）。",
        "A": "数据模型",
        "B": "行为模型",
        "C": "功能模型",
        "D": "结构化分析",
        "answer": "B",
        "explanation": "P204，一般使用状态转换图（State Transform Diagram，STD）表示行为模型，所以选择B。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 107,
        "correct_count": 86,
        "correct_prob": "80.4",
        "fav_count": 4,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22477786ac5e",
        "course_id": 4,
        "id": 40169109,
        "seq": 9,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "软件需求规格说明书（Software Requirement Specification，SRS）是在需求分析阶段需要完成的文档，是软件（）的最终结果，是确保每个要求得以满足所使用的方法。",
        "A": "需求获取",
        "B": "需求分析",
        "C": "测试",
        "D": "验收",
        "answer": "B",
        "explanation": "P208，软件需求规格说明书（Software Requirement Specification，SRS）是在需求分析阶段需要完成的文档，是软件需求分析的最终结果，是确保每个要求得以满足所使用的方法，所以选择B。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 112,
        "correct_count": 89,
        "correct_prob": "79.5",
        "fav_count": 6,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b2207228e93e6",
        "course_id": 4,
        "id": 41459336,
        "seq": 10,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "关于面向对象的基本原则描述不正确的是（）。",
        "A": "抽象：是从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性的特征",
        "B": "封装：把对象的属性和服务结合为一个不可分的系统单位，并尽可能隐蔽对象的内部细节",
        "C": "聚合又称组装，其原则是把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对复杂事物的描述",
        "D": "消息通信：是人类思考问题时经常运用的思想方法，即通过一个事物联想到另外的事物。",
        "answer": "D",
        "explanation": "P207,1）00A的基本原则\n序\t基本原则\t描述\n(1)\t抽象\t是从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性的特征。\n(2)\t封装\t把对象的属性和服务结合为一个不可分的系统单位，并尽可能隐蔽对象的内部细节。这个概念也经常用于从外部隐藏程序单元的内部表示。\n(3)\t继承\t特殊类的对象拥有其对应的一般类的全部属性与服务，称作特殊类对一般类的继承。\n(4)\t分类\t把具有相同属性和服务的对象划分为一类，用类作为这些对象的抽象描述。分类原则实际上是抽象原则运用于对象描述时的一种表现形式.\n(5)\t聚合\t又称组装，其原则是把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对复杂事物的描述。\n(6)\t关联\t关联是人类思考问题时经常运用的思想方法，即通过一个事物联想到另外的事物。能使人发生联想的原因是事物之间确实存在着某些联系。\n(7)\t消息通信\t这一原则要求对象之间只能通过消息进行通信，而不允许在对象之外直接地存取对象内部的属性。通过消息进行通信是由于封装原则而引起的。在00A中要求用消息连接表示出对象之间的动态联系。\n(8)\t粒度控制\t考虑全局时，注意其大的组成部分，暂时不考虑具体的细节，考虑某部分的细节时则暂时撇开其余的部分。这就是粒度控制原则。\n(9)\t行为分析\t现实世界中事物的行为是复杂的，由大量的事物所构成的问题域中，各种行为往往相互依赖、相互交织。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 114,
        "correct_count": 94,
        "correct_prob": "82.5",
        "fav_count": 18,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b221910d2f742",
        "course_id": 4,
        "id": 46146048,
        "seq": 11,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "以下关于常见的需求变更策略，描述不正确的是（）。",
        "A": "每一个集成的需求变更不必一定能跟踪到一个经核准的变更请求",
        "B": "所有需求变更必须遵循变更控制过程",
        "C": "对于未获得批准的变更，不应该做设计和实现工作",
        "D": "应该由项目变更控制委员会决定实现哪些变更",
        "answer": "A",
        "explanation": "P211，常见的需求变更策略主要包括：\n·所有需求变更必须遵循变更控制过程；\n·对于未获得批准的变更，不应该做设计和实现工作；\n·应该由项目变更控制委员会决定实现哪些变更；\n·项目风险承担者应该能够了解变更的内容；\n·绝不能从项目配置库中删除或者修改变更请求的原始文档；\n·每一个集成的需求变更必须能跟踪到一个经核准的变更请求。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 115,
        "correct_count": 104,
        "correct_prob": "90.4",
        "fav_count": 6,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b221a44685ae0",
        "course_id": 4,
        "id": 43887516,
        "seq": 12,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）是一种描述管理系统内各单位、人员之间的业务关系、作业顺序和管理信息流向的图表。",
        "A": "程序流程图",
        "B": "NS流程图",
        "C": "业务流程图",
        "D": "PAD图",
        "answer": "C",
        "explanation": "P215，业务流程图：是一种描述管理系统内各单位、人员之间的业务关系、作业顺序和管理信息流向的图表。业务流程图的绘制是按照业务的实际处理步骤和过程进行的，它用一些规定的符号及连线表示某个具体业务的处理过程，帮助分析人员找出业务流中的不合理流向。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 114,
        "correct_count": 84,
        "correct_prob": "73.7",
        "fav_count": 13,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22485d5337c5",
        "course_id": 4,
        "id": 40014949,
        "seq": 13,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "在常用的00D原则中，（）原则是一个对象应当对其他对象有尽可能少的了解，该原则与结构化方法的（）原则是一致的。",
        "A": "单职 高内聚",
        "B": "组合重用 低耦合",
        "C": "迪米特 低耦合",
        "D": "开闭 高内聚",
        "answer": "C",
        "explanation": "P216，常用的面向对象设计原则包括：\n原则\t说明\n单职原则\t一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。\n开闭原则\t对扩展开放，对修改封闭。\n李氏替换原则\t子类可以替换父类，即子类可以扩展父类的功能，但不能改变父类原有的功能。 \n依赖倒置原则\t要依赖于抽象，而不是具体实现；要针对接口编程，不要针对实现编程。\n接口隔离原则\t使用多个专门的接口比使用单一的总接口要好。\n组合重用原则\t要尽量使用组合，而不是继承关系达到重用目的。\n迪米特原则（最少知识法则）\t一个对象应当对其他对象有尽可能少的了解。其目的是降低类之间的耦合度，提高模块的相对独立性。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 114,
        "correct_count": 91,
        "correct_prob": "79.8",
        "fav_count": 19,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b227114f54311",
        "course_id": 4,
        "id": 42751032,
        "seq": 14,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "统一建模语言（Unified Modeling Language，UML）是一种定义良好、且易于表达、功能强大且普遍适用的（）。",
        "A": "建模语言",
        "B": "编程语言",
        "C": "面向对象方法",
        "D": "架构设计",
        "answer": "A",
        "explanation": "P217，统一建模语言（Unified Modeling Language，UML）是一种定义良好、且易于表达、功能强大且普遍适用的建模语言，所以选择A。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 106,
        "correct_count": 94,
        "correct_prob": "88.7",
        "fav_count": 6,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22411b83024a",
        "course_id": 4,
        "id": 46667120,
        "seq": 15,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）在模型中属于最静态的部分，代表概念上或物理上的元素UML有七种结构事物，分别是类、接口、协作、用例、活动类、构件和节点。",
        "A": "结构事物",
        "B": "分组事物",
        "C": "行为事物",
        "D": "注释事物",
        "answer": "A",
        "explanation": "P218，结构事物在模型中属于最静态的部分，代表概念上或物理上的元素UML有七种结构事物，分别是类、接口、协作、用例、活动类、构件和节点，所以选择A。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 106,
        "correct_count": 87,
        "correct_prob": "82.1",
        "fav_count": 11,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b2253786b6a62",
        "course_id": 4,
        "id": 40377536,
        "seq": 16,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）描述是一般元素和特殊元素之间的分类关系。",
        "A": "依赖",
        "B": "实现",
        "C": "关联",
        "D": "泛化",
        "answer": "D",
        "explanation": "P218，UML用关系把事物结合在一起，主要有4种关系：依赖、关联、泛化和实现：\n序号\t关系\t说明\n①\t依赖\t依赖是两个事物之间的语义关系，其中一个事物发生变化会影响另一个事物的语义。\n②\t关联\t关联是指一种对象和另一种对象有联系。\n③\t泛化\t泛化是一般元素和特殊元素之间的分类关系，描述特殊元素的对象可替换一般元素的对象。\n④\t实现\t实现将不同的模型元素（例如，类）连接起来，其中的一个类指定了由另一个类保证执行的契约。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 112,
        "correct_count": 82,
        "correct_prob": "73.2",
        "fav_count": 22,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b224935a857e2",
        "course_id": 4,
        "id": 49975909,
        "seq": 17,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）描述类中的内部构造，包括结构化类与系统其余部分的交互点。",
        "A": "类图",
        "B": "对象图",
        "C": "构件图",
        "D": "组合结构图",
        "answer": "D",
        "explanation": "P219，组合结构图描述类中的内部构造，包括结构化类与系统其余部分的交互点。组合结构图用于画出结构化类的内部内容。组合结构图比类图更抽象，所以选择D",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 520,
        "correct_count": 221,
        "correct_prob": "42.5",
        "fav_count": 30,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b2237356d2c01",
        "course_id": 4,
        "id": 45653041,
        "seq": 18,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）图描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应。",
        "A": "状态图",
        "B": "包图",
        "C": "交互概览图",
        "D": "活动图",
        "answer": "A",
        "explanation": "P219，状态图描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应。它由状态、转移、事件、活动和动作组成。状态图给出了对象的动态视图。所以选择A。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 520,
        "correct_count": 428,
        "correct_prob": "82.3",
        "fav_count": 12,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b221164dd3281",
        "course_id": 4,
        "id": 44769879,
        "seq": 19,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。",
        "A": "逻辑视图",
        "B": "进程视图",
        "C": "实现视图",
        "D": "部署视图",
        "answer": "A",
        "explanation": "P220逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集，所以选择A。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 109,
        "correct_count": 86,
        "correct_prob": "78.9",
        "fav_count": 16,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22545f2833b5",
        "course_id": 4,
        "id": 46891832,
        "seq": 20,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）是最基本的需求分析模型。",
        "A": "实现视图",
        "B": "用例视图",
        "C": "进程视图",
        "D": "逻辑视图",
        "answer": "B",
        "explanation": "P220，用例视图是最基本的需求分析模型，所以选择B",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 519,
        "correct_count": 252,
        "correct_prob": "48.6",
        "fav_count": 27,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b228811e22408",
        "course_id": 4,
        "id": 40924365,
        "seq": 21,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）又称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。",
        "A": "逻辑视图",
        "B": "进程视图",
        "C": "实现视图",
        "D": "用例视图",
        "answer": "A",
        "explanation": "P220，\n视图\t说明\n逻辑视图\t逻辑视图也称为设计视图，它表示设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。\n进程视图\t进程视图是可执行线程与进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。\n实现视图\t实现视图对组成基于系统的物理代码的文件和构件进行建模。\n部署视图\t部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。\n用例视图\t用例视图是最基本上的需求分析模型。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 103,
        "correct_count": 75,
        "correct_prob": "72.8",
        "fav_count": 20,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b228958bcde9f",
        "course_id": 4,
        "id": 45441891,
        "seq": 22,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "关于设计模式的描述，不正确的是（）。",
        "A": "设计模式包括模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等基本要素",
        "B": "根据处理范围不同，设计模式分为类模式和对象模式",
        "C": "根据目的和用途不同，设计模式分为创建型模式、结构型模式和行为型模式",
        "D": "对象模式处理对象之间的关系，这些关系通过继承建立，在编译的时刻就被确定下来，属于静态关系。",
        "answer": "D",
        "explanation": "P220：设计模式是前人经验的总结，它使人们可以方便地复用成功的软件设计。设计模式包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等基本要素。\n根据处理范围不同，设计模式可分为类模式（静态关系）和对象模式（动态性）。\n根据目的和用途不同，设计模式可分为创建型模式、结构型模式和行为型模式三种。ABC 都正确。\nD答案是错误的。对象模式在运行时刻变化的，动态性的，而不是静态关系。和代码审查",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 101,
        "correct_count": 70,
        "correct_prob": "69.3",
        "fav_count": 26,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22125644934b",
        "course_id": 4,
        "id": 42835671,
        "seq": 23,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "软件测试是发现软件错误（缺陷）的主要手段，软件测试方法可分为静态测试和动态测试，其中（）属于静态测试。",
        "A": "代码走查",
        "B": "功能测试",
        "C": "黑盒测试",
        "D": "白盒测试",
        "answer": "A",
        "explanation": "P223，软件测试方法可分为静态测试和动态测试。静态测试是指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测。对文档的静态测试主要以检查单的形式进行，而对代码的静态测试一般采用桌前检查（Desk Checking）、代码走查和代码审查。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 110,
        "correct_count": 91,
        "correct_prob": "82.7",
        "fav_count": 7,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b223848b18492",
        "course_id": 4,
        "id": 44507666,
        "seq": 24,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "关于软件测试的描述，不正确的是（）。",
        "A": "采用桌前检查、代码走查和代码审查属于动态测试方法",
        "B": "控制流测试和数据流测试属于白盒测试方法",
        "C": "软件测试可分为单元测试、集成测试、确认测试、系统测试等类别",
        "D": "回归测试的目的是在软件变更后，变更部分的正确性和对变更需求的符合性以及功能、性能等要求的不损害性",
        "answer": "A",
        "explanation": "P223，桌前检查、代码走查和代码审查都是静态测试方法，不运行程序的。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 105,
        "correct_count": 87,
        "correct_prob": "82.9",
        "fav_count": 9,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22726d9e67f6",
        "course_id": 4,
        "id": 47058846,
        "seq": 25,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "主流的软件开发工具（IDE）均提供一些插件，用来进行代码的静态检查，帮助开发人员做出质量更高的软件，这种插件所进行的测试不属于（）。",
        "A": "静态测试",
        "B": "白盒测试",
        "C": "代码走查",
        "D": "功能测试",
        "answer": "D",
        "explanation": "P224，只有黑盒测试完全不考虑（或不了解）程序的内部结构和处理算法，主要是进行功能测试。其他三个选项都可以进行代码的静态检查。\nA选项静态测试中有对代码的静态测试，包括桌前检查、代码走查（C选项）和代码审查。\n有的同学会选B选项，白盒测试分为静态白盒测试和动态白盒测试，静态白盒测试里有一个代码检查法。所以B也可以实现代码的静态检查。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 109,
        "correct_count": 61,
        "correct_prob": "56.0",
        "fav_count": 23,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b227331ec9b65",
        "course_id": 4,
        "id": 48923275,
        "seq": 26,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "以下（）不是编码效率的组成部分。",
        "A": "程序效率",
        "B": "算法效率",
        "C": "设计效率",
        "D": "存储效率",
        "answer": "C",
        "explanation": "P222，编码效率。主要包括：程序效率、算法效率、存储效率、I／0效率。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 532,
        "correct_count": 444,
        "correct_prob": "83.5",
        "fav_count": 20,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b2213791d6cc7",
        "course_id": 4,
        "id": 49377961,
        "seq": 27,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "软件配置管理的核心内容包括版本控制和（）。",
        "A": "变更控制",
        "B": "代码控制",
        "C": "发布控制",
        "D": "文档控制",
        "answer": "A",
        "explanation": "P221，软件配置管理的核心内容包括版本控制和变更控制。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 114,
        "correct_count": 97,
        "correct_prob": "85.1",
        "fav_count": 9,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b228a7148fd62",
        "course_id": 4,
        "id": 40614009,
        "seq": 28,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）是软件生命周期中的一个重要环节，属于软件开发的后期活动，即通过配置、安装和激活等活动来保障软件制品的后续运行。",
        "A": "软件编码",
        "B": "软件部署",
        "C": "软件测试",
        "D": "需求分析",
        "answer": "B",
        "explanation": "P225，软件部署是软件生命周期中的一个重要环节，属于软件开发的后期活动，即通过配置、安装和激活等活动来保障软件产品的后续运行，所以选择B。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 504,
        "correct_count": 443,
        "correct_prob": "87.9",
        "fav_count": 6,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22140005398b",
        "course_id": 4,
        "id": 41561374,
        "seq": 29,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）是建立一套有计划、有系统的方法，来向管理层保证拟定出的标准、步骤、实践和方法能够正确地被所有项目所采用。",
        "A": "软件质量保证",
        "B": "软件实施",
        "C": "运营管理",
        "D": "设计模式",
        "answer": "A",
        "explanation": "P229，软件质量保证（Software Quality Assurance，SQA）是建立一套有计划、有系统的方法，来向管理层保证拟定出的标准、步骤、实践和方法能够正确地被所有项目所采用。软件质量保证的目的是使软件过程对于管理人员来说是可见的，它通过对软件产品和活动进行评审和审计来验证软件是合乎标准的。软件质量保证组在项目开始时就一起参与建立计划、标准和过程。这些使软件项目满足机构方针的要求。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 111,
        "correct_count": 86,
        "correct_prob": "77.5",
        "fav_count": 13,
        "sim_questions": ""
      },
      {
        "_id": "c8872b64687f0b33003b22684548cbed",
        "course_id": 4,
        "id": 46531177,
        "seq": 30,
        "test_id": "area_05_01",
        "type": 1,
        "area": 5,
        "tigan": "（）是组织基于软件过程、技术、资源和人员能力达成业务目标的综合能力。包括治理能力、开发与交付能力、管理与支持能力、组织管理能力等方面。",
        "A": "架构设计",
        "B": "需求分析",
        "C": "软件过程能力",
        "D": "软件实现",
        "answer": "C",
        "explanation": "P230，软件过程能力是组织基于软件过程、技术、资源和人员能力达成业务目标的综合能力。包括治理能力、开发与交付能力、管理与支持能力、组织管理能力等方面。所以选择C。",
        "tigan_pic": "",
        "explanation_pic": "",
        "done_count": 511,
        "correct_count": 335,
        "correct_prob": "65.6",
        "fav_count": 14,
        "sim_questions": ""
      }
    ]
  },
  "header": {
    "x-serverless-request-id": "ac1cc31b1757058899440155874",
    "x-serverless-runtime-version": "2.1.3",
    "date": "Fri, 05 Sep 2025 07:54:59 GMT",
    "x-fc-invocation-function-version": "LATEST",
    "x-fc-instance-id": "c-68ba942f-18af72b7-a9dcac77fee5",
    "x-fc-invocation-duration": "37",
    "x-fc-request-id": "1-68ba9753-185a6ed7-a85df2ab3225",
    "transfer-encoding": "chunked",
    "content-type": "application/octet-stream",
    "x-fc-max-memory-usage": "33.47",
    "access-control-expose-headers": "Date,x-fc-request-id,x-fc-error-type,x-fc-code-checksum,x-fc-invocation-duration,x-fc-max-memory-usage,x-fc-log-result,x-fc-invocation-code-version,x-fc-instance-id",
    "x-fc-code-checksum": "3373688905125190371",
    "x-serverless-http-status": "200"
  }
}